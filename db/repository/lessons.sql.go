// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: lessons.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLesson = `-- name: CreateLesson :one
WITH student AS (
	SELECT id, email, password, is_teacher, is_superuser, first_name, middle_name, last_name, slug
	FROM users AS U
	WHERE U.slug = $1
	LIMIT 1
), teacher AS (
	SELECT user_id, subject_ids, biography, id, email, password, is_teacher, is_superuser, first_name, middle_name, last_name, slug
	FROM
		teachers AS T
		INNER JOIN users AS U ON U.id = T.user_id
	WHERE U.slug = $2
	LIMIT 1
)
INSERT INTO lessons (
	student_id
,	teacher_id
,	ts
,	teacher_notes
,	homework
) VALUES (
	(SELECT id FROM student)
,	(SELECT id FROM teacher)
,	$3
,	$4
,	$5
)
RETURNING id, student_id, teacher_id, teacher_notes, homework, ts
`

type CreateLessonParams struct {
	Slug         string
	Slug_2       string
	Ts           pgtype.Timestamptz
	TeacherNotes string
	Homework     string
}

func (q *Queries) CreateLesson(ctx context.Context, arg CreateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, createLesson,
		arg.Slug,
		arg.Slug_2,
		arg.Ts,
		arg.TeacherNotes,
		arg.Homework,
	)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.TeacherID,
		&i.TeacherNotes,
		&i.Homework,
		&i.Ts,
	)
	return i, err
}

const getLessonsByUser = `-- name: GetLessonsByUser :many
SELECT l.id, l.student_id, l.teacher_id, l.teacher_notes, l.homework, l.ts
FROM
	lessons AS L
	INNER JOIN users AS S ON L.student_id = S.id
	INNER JOIN teachers AS T ON L.teacher_id = T.user_id
	INNER JOIN users AS TU ON T.user_id = TU.id
WHERE
	(TU.email = $1 OR S.email = $1) --TODO replace with slugs
	AND L.ts BETWEEN
		    date_trunc('week', CURRENT_DATE) + make_interval(weeks => $2)
		AND date_trunc('week', CURRENT_DATE) + make_interval(weeks => $2, days => 6)
ORDER BY L.ts
`

type GetLessonsByUserParams struct {
	Email string
	Weeks int32
}

func (q *Queries) GetLessonsByUser(ctx context.Context, arg GetLessonsByUserParams) ([]Lesson, error) {
	rows, err := q.db.Query(ctx, getLessonsByUser, arg.Email, arg.Weeks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Lesson
	for rows.Next() {
		var i Lesson
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.TeacherID,
			&i.TeacherNotes,
			&i.Homework,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
